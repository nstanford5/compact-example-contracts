pragma language_version 0.21;
import CompactStandardLibrary;

enum Winner {
    UNSET,
    SET
}

export ledger raffleOrganizer: ZswapCoinPublicKey;
export ledger hashedWinningNum: Bytes<32>;
export ledger publicWinningNum: Uint<8>;
export ledger winner: ZswapCoinPublicKey;
export ledger state: Winner;
export ledger assignedNumbers: Counter;
export ledger assignedTicketHolders: Map<ZswapCoinPublicKey, Uint<8>>;

constructor(winningNum: Uint<8>, sk: Bytes<32>) {
    assert(winningNum >= 1 && winningNum <= 10, "Winning number must be between 1-10");
    raffleOrganizer = ownPublicKey();
    hashedWinningNum = commitWithSk(winningNum as Bytes<32>, sk);
    state = Winner.UNSET;
    // @TODO -- add token deposit to ensure organizer reveals
}

// @TODO -- add token deposit to buy ticket
export circuit getTicket() : Uint<8> {
    assert(state == Winner.UNSET, "A winner has already been declared");
    assert(assignedNumbers < 10, "Max tickets reached");

    const pubKey = ownPublicKey();
    assert(!assignedTicketHolders.member(pubKey), "You are already in the list");
    assert(pubKey != raffleOrganizer, "The organizer cannot participate");

    assignedNumbers.increment(1);// account for 0 index for users
    assignedTicketHolders.insert(pubKey, assignedNumbers as Uint<8>);
    return assignedNumbers as Uint<8>;
}

export circuit revealWinner(winningNum: Uint<8>, sk: Bytes<32>) : [] {
    assert(ownPublicKey() == raffleOrganizer, "You are not the organizer");

    const commitCheck = commitWithSk(winningNum as Bytes<32>, sk);
    assert(commitCheck == hashedWinningNum, "Wrong winning number provided, shame on you");    
    publicWinningNum = disclose(winningNum);
    state = Winner.SET;
}

// @TODO -- send tokens to winner
export circuit claimWin() : [] {
    const pubKey = ownPublicKey();
    assert(assignedTicketHolders.member(pubKey), "You are not an assigned ticket holder");
    assert(assignedTicketHolders.lookup(pubKey) == publicWinningNum, "You do not have the winning number");
    winner = pubKey;
}
 
circuit commitWithSk(winningNum: Bytes<32>, sk: Bytes<32>) : Bytes<32> {
    return disclose(persistentHash<Vector<2, Bytes<32>>>([winningNum, sk]));
}

export circuit publicKey(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([pad(32, "tip-board:pk:"), sk]);
}