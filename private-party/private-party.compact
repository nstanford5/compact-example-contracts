// rename to private-guest-list?
pragma language_version 0.21;

import CompactStandardLibrary;

// organizers are public
export ledger organizerPks: Set<ZswapCoinPublicKey>;
// participants are hashed until they arrive
export ledger hashedPartyGoers: Set<Bytes<32>>;
export ledger checkedInParty: Set<Bytes<32>>;

// maybe add initial list of participants?
constructor(){
    organizerPks.insert(ownPublicKey());
}

export circuit addOrganizer(): [] {
    const organizerPk = ownPublicKey();
    assert(organizerPks.member(organizerPk), "You are not an organizer");
    assert(!organizerPks.member(organizerPk), "You are already in the organizer list");
    
    organizerPks.insert(organizerPk);
}

// to be called by Organizer
export circuit addParticipant(participantPk: Bytes<32>, OrganizerSk: Bytes<32>): [] {
    assert(organizerPks.member(ownPublicKey()), "You are not an organizer");
    hashedPartyGoers.insert(disclose(commitWithSk(participantPk, OrganizerSk)));
}

export circuit checkIn(participantPk: Bytes<32>, organizerSk: Bytes<32>): [] {
    assert(organizerPks.member(ownPublicKey()), "You are not an organizer");

    assert(hashedPartyGoers.member(commitWithSk(participantPk, organizerSk)), "You are not on the list");
    checkedInParty.insert(disclose(participantPk));
}

circuit commitWithSk(participantPk: Bytes<32>, sk: Bytes<32>) : Bytes<32> {
    return disclose(persistentHash<Vector<2, Bytes<32>>>([participantPk, sk]));
}

export circuit publicKey(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([pad(32, "welcome-party:pk:"), sk]);
}
