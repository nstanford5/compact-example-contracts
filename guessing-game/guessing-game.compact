pragma language_version 0.21;

import CompactStandardLibrary;

enum State {
    UNSET,
    SET
}

export ledger state: State;
export ledger player1: Bytes<32>;
export ledger numHash: Bytes<32>;

constructor(sk: Bytes<32>) {
    player1 = disclose(publicKey(sk));
    state = State.UNSET;
}

// called by player2 to accept the challenge of guessing the number
export circuit accept(player1Pk: Bytes<32>, sk: Bytes<32>, numberGuess: Uint<8>): Boolean {
    assert(state == State.SET, "No player1 present");
    assert(player1 != publicKey(sk), "You can't play against yourself");
    // do I need player2 to pass in player1Pk and verify this?
    assert(player1Pk == player1, "This is the wrong game");
    const result = guessNum(numberGuess, sk);
    return result;
}

export circuit onChainSetNum(num: Uint<8>, sk: Bytes<32>): [] {
    assert(player1 == publicKey(sk), "You are not player 1");
    assert(state == State.UNSET, "The number is already set");
    numHash = disclose(commitWithSk(num as Bytes<32>, sk));
    state = State.SET;
}

export circuit guessNum(num: Uint<8>, sk: Bytes<32>): Boolean {
    const guessHash = disclose(commitWithSk(num as Bytes<32>, sk));
    return guessHash == numHash;
}

circuit commitWithSk(num: Bytes<32>, sk: Bytes<32>): Bytes<32> {
    return disclose(persistentHash<Vector<2, Bytes<32>>>([num, sk]));
}

export circuit publicKey(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([pad(32, "guessing-game:pk:"), sk]);
}
