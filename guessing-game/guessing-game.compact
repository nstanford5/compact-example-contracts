/**
    Guess the number game between 2 players, where player 1 sets a number(hashed)
    and player 2 has to guess that number
**/
pragma language_version 0.21;
import CompactStandardLibrary;

enum State {
    UNSET,
    SET
}

export ledger state: State;
export ledger player1: ZswapCoinPublicKey;
export ledger numHash: Bytes<32>;

constructor(sk: Bytes<32>) {
    player1 = ownPublicKey();
    state = State.UNSET;
}

// called by player2 to accept the challenge of guessing the number
export circuit accept(player1Pk: ZswapCoinPublicKey, sk: Bytes<32>, numberGuess: Uint<8>): Boolean {
    assert(state == State.SET, "No player1 present");
    assert(player1 != ownPublicKey(), "You can't play against yourself");
    // do I need player2 to pass in player1Pk and verify this?
    assert(player1Pk == player1, "This is the wrong game");
    const result = guessNum(numberGuess, sk);
    return result;
}

export circuit onChainSetNum(num: Uint<8>, sk: Bytes<32>): [] {
    assert(player1 == ownPublicKey(), "Only player1 can set the number");
    assert(state == State.UNSET, "The number is already set");
    assert(num >= 1 && num <= 5, "Please pick a number between 1-5");
    
    numHash = disclose(commitWithSk(num as Bytes<32>, sk));
    state = State.SET;
}

export circuit guessNum(num: Uint<8>, sk: Bytes<32>): Boolean {
    assert(ownPublicKey() != player1, "Only player2 can guess the number");
    const guessHash = disclose(commitWithSk(num as Bytes<32>, sk));
    return guessHash == numHash;
}

circuit commitWithSk(num: Bytes<32>, sk: Bytes<32>): Bytes<32> {
    return disclose(persistentHash<Vector<2, Bytes<32>>>([num, sk]));
}

export circuit publicKey(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([pad(32, "guessing-game:pk:"), sk]);
}
