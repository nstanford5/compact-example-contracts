pragma language_version 0.21;

import CompactStandardLibrary;

enum PublicState { setup, commit, reveal, final, }
enum PrivateState { initial, committed, revealed, }
enum PermissibleVotes { yes, no }

export ledger authority: Bytes<32>;
export ledger state: PublicState;
export ledger topic: Maybe<Opaque<"string">>;
export ledger tally_yes: Counter;
export ledger tally_no: Counter;
export ledger eligible_voters: MerkleTree<10, Bytes<32>>;
export ledger committed_votes: MerkleTree<10, Bytes<32>>;
export ledger committed: Set<Bytes<32>>;
export ledger revealed: Set<Bytes<32>>;

witness private$secret_key(): Bytes<32>;
witness private$state(): PrivateState;
witness private$state$advance(): [];
witness private$vote$record(ballot: PermissibleVotes): [];
witness private$vote(): PermissibleVotes;
witness context$eligible_voters$path_of(pk: Bytes<32>): Maybe<MerkleTreePath<10, Bytes<32>>>;
witness context$committed_votes$path_of(cm: Bytes<32>): Maybe<MerkleTreePath<10, Bytes<32>>>;

circuit ballot_repr(ballot: PermissibleVotes): Bytes<32> {
  return ballot == PermissibleVotes.yes ? pad(32, "yes") : pad(32, "no");
}

circuit vote$commit(ballot: PermissibleVotes): [] {
  assert ((state.read() == PublicState.commit && private$state() == PrivateState.initial), "In illegal state for committing");
  private$vote$record(ballot);
  const sk = private$secret_key();
  const com_nul = commitment_nullifier(sk);
  assert (!committed.member(com_nul), "Unexpected attempt to double use of nullifier");
  const pk = public_key(sk);
  const path = context$eligible_voters$path_of(pk);
  assert ((path.is_some &&
          eligible_voters.checkRoot(merkleTreePathRoot<10, Bytes<32>>(path.value)) &&
          pk == path.value.leaf), "Attempted to vote without authorization - need to add-voter");
  const cm = commit_with_sk(ballot_repr(ballot), sk);
  committed_votes.insert(cm);
  committed.insert(com_nul);
  private$state$advance();
}

circuit vote$reveal(): [] {
  assert (state.read() == PublicState.reveal && private$state() == PrivateState.committed, "In illegal state for revealing");
  const sk = private$secret_key();
  const rev_nul = reveal_nullifier(sk);
  assert (!revealed.member(rev_nul), "Attempted to double vote");
  const vote = private$vote();
  const cm = commit_with_sk(ballot_repr(vote), sk);
  const path = context$committed_votes$path_of(cm);
  assert (path.is_some &&
          committed_votes.checkRoot(merkleTreePathRoot<10, Bytes<32>>(path.value)) &&
          cm == path.value.leaf, "Attempted to reveal incorrectly");
  if(vote == PermissibleVotes.yes) {
    tally_yes.increment(1);
  } else {
    tally_no.increment(1);
  }
  revealed.insert(rev_nul);
  private$state$advance();
}

circuit advance(): [] {
  const sk = private$secret_key();
  const apk = public_key(sk);
  assert (apk == authority.read(), "Attempted to advance state without authorization");
  assert (topic.read().is_some, "Attempted to start election without a topic");
  state.write(successor(state.read()));
}

circuit successor(state: PublicState): PublicState {
  if(state == PublicState.setup) {
    return PublicState.commit;
  } else if(state == PublicState.commit) {
    return PublicState.reveal;
  } else {
    return PublicState.final;
  }
}

circuit set_topic(t: Opaque<"string">): [] {
  const sk = private$secret_key();
  const apk = public_key(sk);
  assert (apk == authority.read(), "Attempted to set topic without authorization");
  assert (state.read() == PublicState.setup, "Attempted to set topic after setup phase");
  topic.write(Maybe<Opaque<"string">>{ is_some: true, value: t });
}

circuit add_voter(pk: Bytes<32>): [] {
  assert (!context$eligible_voters$path_of(pk).is_some, "Attempted to add a voter twice");
  const sk = private$secret_key();
  const apk = public_key(sk);
  assert (apk == authority.read(), "Attempted to add a voter without authorization");
  assert (state.read() == PublicState.setup, "Attempted to add a voter after setup phase");
  eligible_voters.insert(pk);
}

export circuit commitment_nullifier(sk: Bytes<32>): Bytes<32> {
  return disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "lares:election:cm-nul:"), sk]));
}

export circuit reveal_nullifier(sk: Bytes<32>): Bytes<32> {
  return disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "lares:election:rv-nul:"), sk]));
}

export circuit public_key(sk: Bytes<32>): Bytes<32> {
  return disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "lares:election:pk:"), sk]));
}

export circuit commit_with_sk(ballot: Bytes<32>, sk: Bytes<32>): Bytes<32> {
  return disclose(persistentHash<Vector<2, Bytes<32>>>([ballot, sk]));
}