/**
    An aution where the bidders are private. Only bids are public,
    and the winner is never disclosed.
**/
pragma language_version 0.21;
import CompactStandardLibrary;

enum Winner {
    UNSET,
    SET
}

enum Bids {
    OPEN,
    CLOSED
}

export ledger auctionOrganizer: ZswapCoinPublicKey;
export ledger highestBid: Uint<8>;
export ledger hashedBids: Map<Bytes<32>, Bytes<32>>;
export ledger winner: Bytes<32>;
export ledger winState: Winner;
export ledger bidState: Bids;
export ledger bidCount: Counter;

constructor(sk: Bytes<32>) {
    auctionOrganizer = ownPublicKey();
    highestBid = 0;
    winState = Winner.UNSET;
    bidState = Bids.OPEN;
}

// I suppose the frontend would need to track bidState to determine when to 
// allow claims
export circuit makeBid(bidAmount: Uint<8>, sk: Bytes<32>) : [] {
    assert(bidState == Bids.OPEN, "Sorry, bidding has closed");
    assert(ownPublicKey() != auctionOrganizer, "Organizer cannot make bids");

    const pubKeyHash = disclose(publicKey(sk));
    assert(!hashedBids.member(pubKeyHash), "You can only bid once");

    hashedBids.insert(pubKeyHash, commitWithSk(pubKeyHash, bidAmount as Bytes<32>, sk));
    const publicBid = disclose(bidAmount);
    if(publicBid > highestBid) {
        highestBid = publicBid;
    }
    bidCount.increment(1);
    if(bidCount == 9){
        bidState = Bids.CLOSED;
    }
}

export circuit claim(bidAmount: Uint<8>, sk: Bytes<32>) : Bytes<32> {
    assert(bidState == Bids.CLOSED, "Bids are still open");
    const pubKeyHash = disclose(publicKey(sk));
    assert(hashedBids.member(pubKeyHash), "You are not a registered bidder");

    const bid = commitWithSk(pubKeyHash, bidAmount as Bytes<32>, sk);
    assert(hashedBids.lookup(pubKeyHash) == bid, "Wrong bid amount provided");
    
    const winningBidHash = commitWithSk(pubKeyHash, highestBid as Bytes<32>, sk);
    assert(bid == winningBidHash, "Winning bid hash mismatch");
    winState = Winner.SET;
    return pubKeyHash;
}

circuit commitWithSk(bidderPk: Bytes<32>, bidAmount: Bytes<32>, sk: Bytes<32>) : Bytes<32> {
    return disclose(persistentHash<Vector<3, Bytes<32>>>([bidderPk, bidAmount, sk]));
}

export circuit publicKey(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([pad(32, "private-auction:pk:"), sk]);
}
