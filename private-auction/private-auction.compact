/**
     An aution where the bidders and their bids are private. The only public
     bid is the winning one, and the winner is never disclosed.
**/
pragma language_version 0.21;
import CompactStandardLibrary;

enum Winner {
    UNSET,
    SET
}

export ledger auctionOrganizer: Bytes<32>;
export ledger highestBid: Uint<8>;
export ledger hashedBids: Map<Bytes<32>, Bytes<32>>;
export ledger winner: Bytes<32>;
export ledger state: Winner;
export ledger bidCount: Counter;

constructor(sk: Bytes<32>) {
    auctionOrganizer = disclose(publicKey(sk));
    highestBid = 0;
    state = Winner.UNSET;
}

export circuit makeBid(bidAmount: Uint<8>, sk: Bytes<32>) : [] {
    assert(bidCount < 9, "Max number of bids reached");
    const pubKeyHash = disclose(publicKey(sk));
    assert(!hashedBids.member(pubKeyHash), "You can only bid once");
    hashedBids.insert(pubKeyHash, commitWithSk(pubKeyHash, bidAmount as Bytes<32>, sk));
    const publicBid = disclose(bidAmount);
    if(publicBid > highestBid) {
        highestBid = publicBid;
    }
    bidCount.increment(1);
}

export circuit claim(bidAmount: Uint<8>, sk: Bytes<32>) : Bytes<32> {
    assert(bidCount == 9, "Bids are not yet complete");
    const pubKeyHash = disclose(publicKey(sk));
    assert(hashedBids.member(pubKeyHash), "You are not a registered bidder");

    const bid = commitWithSk(pubKeyHash, bidAmount as Bytes<32>, sk);
    assert(hashedBids.lookup(pubKeyHash) == bid, "Wrong bid amount provided");
    
    const winningBidHash = commitWithSk(pubKeyHash, highestBid as Bytes<32>, sk);
    assert(bid == winningBidHash, "Winning bid hash mismatch");
    state = Winner.SET;
    return pubKeyHash;
}

circuit commitWithSk(bidderPk: Bytes<32>, bidAmount: Bytes<32>, sk: Bytes<32>) : Bytes<32> {
    return disclose(persistentHash<Vector<3, Bytes<32>>>([bidderPk, bidAmount, sk]));
}

export circuit publicKey(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([pad(32, "private-auction:pk:"), sk]);
}

